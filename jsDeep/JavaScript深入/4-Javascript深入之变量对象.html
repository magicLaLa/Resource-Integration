<!DOCTYPE html>
<html lang="en">
<head>
<title></title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body></body>
</html>
<script>
/*
  当 JavaScript 代码执行一段可执行代码(executable code)时，
  会创建对应的执行上下文(execution context)。
  对于每个执行上下文，都有三个重要属性：

    变量对象(Variable object，VO)
    作用域链(Scope chain)
    this
*/
/*
  变量对象
  变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明
  (全局上下文下的变量对象和函数上下文下的变量对象)
*/
/*
  全局上下文下的变量对象 就是 全局对象
*/


/*
  函数上下文：
    在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象
    活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，
    不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的
    变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，
    也就是活动对象上的各种属性才能被访问。
    活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。
    arguments 属性值是 Arguments 对象。

    补充:
      变量对象(VO)和 活动对象(AO) 的区别
      进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，
      变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。
      它们其实都是同一个对象，只是处于执行上下文的不同生命周期

    补充：
      AO 实际上是包含了 VO 的。因为除了 VO 之外，AO 还包含函数的 parameters，
      以及 arguments 这个特殊对象。也就是说 AO 的确是在进入到执行阶段的时候被激活，
      但是激活的除了 VO 之外，还包括函数执行时传入的参数和 arguments 这个特殊对象。
      AO = VO + function parameters + arguments
*/
// 一个执行上下文的生命周期可以分为两个阶段。
// 1.创建阶段
// 在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
// 2.代码执行阶段
// 创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。
/*
  进入执行上下文

    当进入执行上下文时，这时候还没有执行代码，

    变量对象会包括：

    函数的所有形参 (如果是函数上下文)

    由名称和对应值组成的一个变量对象的属性被创建
    没有实参，属性值设为 undefined
    函数声明

    由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
    如果变量对象已经存在相同名称的属性，则完全替换这个属性
    变量声明

    由名称和对应值（undefined）组成一个变量对象的属性被创建；
    如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
*/

/*
  代码执行

    在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
*/

/*
  变量对象的创建过程:
    全局上下文的变量对象初始化是全局对象
    函数上下文的变量对象初始化只包括 Arguments 对象
    在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
    在代码执行阶段，会再次修改变量对象的属性值
*/


// function ss() {
//   console.log(a)
//   a = 1
// }
// ss()// Uncaught ReferenceError: a is not defined

/*
  函数中的 "a" 并没有通过 var 关键字声明，所有不会被存放在 AO 中
  在全局中去找也没有找到，所以报错
  AO = {
    arguments: {
        length: 0
    }
  }
*/

console.log(foo)
function foo () {
  console.log("foo")
}
var foo = 1;// 输出 函数
/*
  在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，
  如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
  function声明会比var声明优先级更高一点(同一作用域下,函数提升比变量提升得更靠前)
  根本原因就是 执行顺序和词法分析决定了 谁覆盖谁
*/
console.log(a)// function
var a = 1
console.log(a)// 1
function a() {
  console.log('这个函数')
}
</script>